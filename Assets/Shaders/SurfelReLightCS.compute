#pragma kernel CSMain

#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
#pragma multi_compile _ _SHADOWS_SOFT _SHADOWS_SOFT_LOW _SHADOWS_SOFT_MEDIUM _SHADOWS_SOFT_HIGH

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl"
#include "SH.hlsl"

struct Surfel
{
    float3 position;
    float3 normal;
    float3 albedo;
    float skyMask;
};

RWStructuredBuffer<Surfel> _surfels;
RWStructuredBuffer<int> _coefficientSH9;
RWTexture3D<int> _coefficientVoxel3D;
Texture3D<int> _lastFrameCoefficientVoxel3D;

float _skyLightIntensity;
float4 _probePos;
int _indexInProbeVolume;
float _GIIntensity;
float _coefficientVoxelGridSize;
float4 _coefficientVoxelCorner;
float4 _coefficientVoxelSize;

// =============================== Debugging =================================== //
RWStructuredBuffer<float3> _surfelRadiance;
// =============================== Debugging =================================== //

// Convert probe index to 3D texture coordinates
int3 ProbeIndexToTexture3DCoord(int probeIndex, int shIndex, int componentIndex, float4 voxelSize)
{
    // Convert 1D probe index to 3D grid coordinates
    int probeSizeY = int(voxelSize.y);
    int probeSizeZ = int(voxelSize.z);
    
    int x = probeIndex / (probeSizeY * probeSizeZ);
    int temp = probeIndex % (probeSizeY * probeSizeZ);
    int y = temp / probeSizeZ;
    int z = temp % probeSizeZ;
    
    // Convert to 3D texture coordinates
    // Layout: [probeSizeX, probeSizeZ, probeSizeY * 9 * 3]
    // componentIndex: 0=R, 1=G, 2=B
    int3 texCoord;
    texCoord.x = x;
    texCoord.y = z;  // Z becomes Y in texture
    texCoord.z = (y * 9 + shIndex) * 3 + componentIndex;  // (Y * 9 + SH index) * 3 + component
    
    return texCoord;
}

[numthreads(32,16,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint surfelIndex = id.x * 16 + id.y;
    Surfel surfel = _surfels[surfelIndex];

    // mainlight property
    Light mainLight = GetMainLight();

    // mainlight shadow mask in URP
    float4 shadowCoord = TransformWorldToShadowCoord(surfel.position);
    float atten = SampleShadowmap(
        TEXTURE2D_ARGS(_MainLightShadowmapTexture, sampler_MainLightShadowmapTexture), 
        shadowCoord, 
        GetMainLightShadowSamplingData(), 
        GetMainLightShadowParams(), 
        false
    );

    // radiance from light
    float NdotL = saturate(dot(surfel.normal, mainLight.direction));
    float3 radiance = surfel.albedo * mainLight.color * NdotL * atten * (1.0 - surfel.skyMask);
    
    // direction from probe to surfel
    float3 dir = normalize(surfel.position - _probePos.xyz);

    // radiance from sky
    float3 skyColor = SAMPLE_TEXTURECUBE_LOD(_GlossyEnvironmentCubeMap, sampler_GlossyEnvironmentCubeMap, dir, 0).rgb;
    radiance += skyColor * surfel.skyMask * _skyLightIntensity;  

    // radiance from last frame
    float3 history = float3(0, 0, 0);
    history = SampleSHVoxel3D(
        surfel.position, 
        surfel.albedo, 
        surfel.normal,
        _lastFrameCoefficientVoxel3D,
        _coefficientVoxelGridSize,
        _coefficientVoxelCorner,
        _coefficientVoxelSize
    );
    radiance += history * _GIIntensity;

    // SH projection
    const float N = 32 * 16;
    float3 c[9];
    c[0] = SH(0, 0, dir) * radiance * 4.0 * PI / N;
    c[1] = SH(1, -1, dir) * radiance * 4.0 * PI / N;
    c[2] = SH(1, 0, dir) * radiance * 4.0 * PI / N;
    c[3] = SH(1, 1, dir) * radiance * 4.0 * PI / N;
    c[4] = SH(2, -2, dir) * radiance * 4.0 * PI / N;
    c[5] = SH(2, -1, dir) * radiance * 4.0 * PI / N;
    c[6] = SH(2, 0, dir) * radiance * 4.0 * PI / N;
    c[7] = SH(2, 1, dir) * radiance * 4.0 * PI / N;
    c[8] = SH(2, 2, dir) * radiance * 4.0 * PI / N;

    // atom write result to buffer
    for (int i = 0; i < 9; i++)
    {
        InterlockedAdd(_coefficientSH9[i * 3 + 0], EncodeFloatToInt(c[i].x));
        InterlockedAdd(_coefficientSH9[i * 3 + 1], EncodeFloatToInt(c[i].y));
        InterlockedAdd(_coefficientSH9[i * 3 + 2], EncodeFloatToInt(c[i].z));
    }

    /**/
    // storage to volume
    if (_indexInProbeVolume >= 0)
    {
        // Write to 3D texture using reduced coefficients
        // Write each RGB component separately
        for (int i = 0; i < 9; i++)
        {
            int3 texCoordR = ProbeIndexToTexture3DCoord(_indexInProbeVolume, i, 0, _coefficientVoxelSize);
            int3 texCoordG = ProbeIndexToTexture3DCoord(_indexInProbeVolume, i, 1, _coefficientVoxelSize);
            int3 texCoordB = ProbeIndexToTexture3DCoord(_indexInProbeVolume, i, 2, _coefficientVoxelSize);
                
            InterlockedAdd(_coefficientVoxel3D[texCoordR], EncodeFloatToInt(c[i].x));
            InterlockedAdd(_coefficientVoxel3D[texCoordG], EncodeFloatToInt(c[i].y));
            InterlockedAdd(_coefficientVoxel3D[texCoordB], EncodeFloatToInt(c[i].z));
        }
    }
    
    // for debug
    _surfelRadiance[surfelIndex] = radiance;
}
